{"version":3,"sources":["quadtree.coffee"],"names":["root","factory","define","amd","exports","module","this","Quadtree","arg","child","that","x","y","width","height","maxElements","Error","contents","oversized","size","Number","isInteger","children","NW","create","Math","max","floor","tree","NE","ceil","SW","SE","get","boundingBoxCollision","calculateDirection","fitting","getCenter","observe","splitTree","validateElement","item","ref","ref1","elt1","elt2","ref2","ref3","element","quadCenter","bottomHeight","leftWidth","rightWidth","topHeight","coordinates","direction","where","push","writeAccessors","propName","Object","defineProperty","set","val","remove","configurable","doObserve","pushAll","items","candidate","content","contentDir","elements","fifo","fifoCandidates","fits","j","k","l","len","len1","len2","relatedChild","length","shift","index","indexOf","splice","colliding","collisionFunction","elt","top","query","check","key","find","each","action","i","predicate","filter","deepclone","target","copycat","reject","visit","bind","pretty","indent","indentation","isParent","str","level","res","label","unshift"],"mappings":"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","file":"quadtree.min.js","sourcesContent":["# quadtree-lib\n# ============\n#\n# **Quadtree-lib** is an easy to use, developer friendly quadtree library\n# which contains many helper methods to add, remove, iterate, filter, simulate\n# collisions over 2d elements and more.\n\n# #### UMD bundling related code\n((root, factory) ->\n    if typeof define is 'function' and define.amd\n        define [], factory\n    else if typeof exports is 'object' and module.exports\n        module.exports = factory()\n    else\n        root['Quadtree'] = factory()\n) @, (-> class Quadtree\n    # The Quadtree class\n    # -------------------\n\n    # ### Constructor\n\n    # The quadtree constructor accepts a single parameter object containing the following properties :\n    # - width / length : dimensions of the quadtree. [ *mandatory* ]\n    # - maxElements : the maximum number of elements before the leaf 'splits' into subtrees. [ *defaults to 1* ]\n    # - x / y : these coordinates are used internally by the library to position subtrees. [ *internal use only* ]\n    constructor: ({ @x, @y, @width, @height, @maxElements }) ->\n\n        # An error is thrown when the width & length are not passed as constructor arguments.\n        throw new Error 'Missing quadtree dimensions.' if not @width? or not @height?\n        @x ?= 0\n        @y ?= 0\n        @maxElements ?= 1\n        @contents = []\n        @oversized = []\n        @size = 0\n\n        # Dimension & coordinates are checked, an error is thrown in case of bad input.\n        throw new Error 'Dimensions must be positive integers.' if @width < 1 or @height < 1\n        throw new Error 'Coordinates must be integers' if not Number.isInteger(@x) or not Number.isInteger(@y)\n        throw new Error 'The maximum number of elements before a split must be a positive integer.' if @maxElements < 1\n\n        that = @\n\n        # The subtrees list, by position.\n        @children = {\n            # Northwest tree.\n            NW:\n                create: ->\n                    new Quadtree({\n                        x: that.x\n                        y: that.y\n                        width: Math.max (Math.floor that.width / 2), 1\n                        height: Math.max (Math.floor that.height / 2), 1\n                        maxElements: that.maxElements\n                    })\n                tree: null\n            # Northeast tree.\n            NE:\n                create: ->\n                    new Quadtree({\n                        x: that.x + Math.max (Math.floor that.width / 2), 1\n                        y: that.y\n                        width: Math.ceil that.width / 2\n                        height: Math.max (Math.floor that.height / 2), 1\n                        maxElements: that.maxElements\n                    })\n                tree: null\n            # Southwest tree.\n            SW:\n                create: ->\n                    new Quadtree({\n                        x: that.x\n                        y: that.y + Math.max (Math.floor that.height / 2), 1\n                        width: Math.max (Math.floor that.width / 2), 1\n                        height: Math.ceil that.height / 2\n                        maxElements: that.maxElements\n                    })\n                tree: null\n            # Southeast tree.\n            SE:\n                create: ->\n                    new Quadtree({\n                        x: that.x + Math.max (Math.floor that.width / 2), 1\n                        y: that.y + Math.max (Math.floor that.height / 2), 1\n                        width: Math.ceil that.width / 2\n                        height: Math.ceil that.height / 2\n                        maxElements: that.maxElements\n                    })\n                tree: null\n        }\n        # Adding a getter which lazily creates the tree.\n        for child of @children\n            @children[child].get = ->\n                if @tree? then @tree else @tree = @create(); @tree\n\n    # ### Internal methods & vars\n\n    # Retrieves the center coordinates of a rectangle.\n    getCenter = (item) ->\n        x: Math.floor((item.width  ? 1) / 2) + item.x\n        y: Math.floor((item.height ? 1) / 2) + item.y\n\n    # Bounding box collision algorithm.\n    boundingBoxCollision = (elt1, elt2) ->\n        not(elt1.x >= elt2.x + (elt2.width ? 1)      or\n            elt1.x + (elt1.width ? 1) <= elt2.x      or\n            elt1.y >= elt2.y + (elt2.height ? 1)     or\n            elt1.y + (elt1.height ? 1) <= elt2.y)\n\n    # Determines which subtree an element belongs to.\n    calculateDirection = (element, tree) ->\n        quadCenter = getCenter tree\n\n        if element.x < quadCenter.x\n            if element.y < quadCenter.y then 'NW'\n            else 'SW'\n        else\n            if element.y < quadCenter.y then 'NE'\n            else 'SE'\n\n    # Validates a potential element of the tree.\n    validateElement = (element) ->\n        if not (typeof element is 'object')\n            throw new Error 'Element must be an Object.'\n        if not element.x? or not element.y?\n            throw new Error 'Coordinates properties are missing.'\n        if element?.width < 0 or element?.height < 0\n            throw new Error 'Width and height must be positive integers.'\n\n    # Returns splitted coordinates and dimensions.\n    splitTree = (tree) ->\n        leftWidth    = Math.max (Math.floor tree.width / 2), 1\n        rightWidth   = Math.ceil tree.width / 2\n        topHeight    = Math.max (Math.floor tree.height / 2), 1\n        bottomHeight = Math.ceil tree.height / 2\n        NW:\n            x: tree.x\n            y: tree.y\n            width: leftWidth\n            height: topHeight\n        NE:\n            x: tree.x + leftWidth\n            y: tree.y\n            width: rightWidth\n            height: topHeight\n        SW:\n            x: tree.x\n            y: tree.y + topHeight\n            width: leftWidth\n            height: bottomHeight\n        SE:\n            x: tree.x + leftWidth\n            y: tree.y + topHeight\n            width: rightWidth\n            height: bottomHeight\n\n    # Determines wether an element fits into subtrees.\n    fitting = (element, tree) ->\n        where = []\n        for direction, coordinates of splitTree tree when boundingBoxCollision element, coordinates\n            where.push direction\n        where\n\n    # Add getters and setters for coordinates and dimensions properties in order to automatically reorganize the elements on change.\n    observe = (item, tree) ->\n        writeAccessors = (propName) ->\n            item[\"_#{propName}\"] = item[propName]\n            Object.defineProperty item, propName, {\n                set: (val) ->\n                    tree.remove @\n                    @[\"_#{propName}\"] = val\n                    tree.push @\n                get: ->\n                    @[\"_#{propName}\"]\n                configurable: true\n            }\n        writeAccessors 'x'\n        writeAccessors 'y'\n        writeAccessors 'width'\n        writeAccessors 'height'\n\n    # ### Exposed methods\n\n    # Add an element to the quadtree.\n    # Elements can be observed to reorganize them into the quadtree automatically whenever their coordinates or dimensions are set (for ex. obj.x = ...).\n    push: (item, doObserve) ->\n        @pushAll([item], doObserve)\n\n    # Push an array of elements.\n    pushAll: (items, doObserve) ->\n        for item in items\n            validateElement item\n            observe item, @ if doObserve\n\n        fifo = [tree: @, elements: items]\n\n        while fifo.length > 0\n            { tree, elements } = fifo.shift()\n\n            fifoCandidates = { NW: null, NE: null, SW: null, SE: null }\n\n            for element in elements\n                tree.size++\n\n                fits = fitting element, tree\n\n                if fits.length isnt 1 or tree.width is 1 or tree.height is 1\n                    tree.oversized.push element\n\n                else if (tree.size - tree.oversized.length) <= tree.maxElements\n                    tree.contents.push element\n\n                else\n                    direction = fits[0]\n                    relatedChild = tree.children[direction]\n                    fifoCandidates[direction] ?= { tree: relatedChild.get(), elements: [] }\n                    fifoCandidates[direction].elements.push(element)\n\n                    for content in tree.contents\n                        contentDir = (fitting content, tree)[0]\n                        fifoCandidates[contentDir] ?= { tree: tree.children[contentDir].get(), elements: [] }\n                        fifoCandidates[contentDir].elements.push(content)\n\n                    tree.contents = []\n\n            for direction, candidate of fifoCandidates\n                if candidate? then fifo.push candidate\n\n        @\n\n    # Removes an element from the quadtree.\n    remove: (item) ->\n        validateElement item\n\n        index = @oversized.indexOf item\n        if index > -1\n            @oversized.splice index, 1\n            @size--\n            return true\n\n        index = @contents.indexOf item\n        if index > -1\n            @contents.splice index, 1\n            @size--\n            return true\n\n        relatedChild = @children[calculateDirection item, @]\n\n        if relatedChild.tree? and relatedChild.tree.remove item\n            @size--\n            relatedChild.tree = null if relatedChild.tree.size is 0\n            return true\n\n        false\n\n    # Returns an array of elements which collides with the `item` argument.\n    # `item` being an object having x, y, width & height properties.\n\n    # The default collision function is a basic bounding box algorithm.\n    # You can change it by providing a function as a second argument.\n    #```javascript\n    #colliding({x: 10, y: 20}, function(element1, element2){\n    #    return // Place predicate here //\n    #})\n    #```\n    colliding: (item, collisionFunction) ->\n        validateElement item\n\n        collisionFunction ?= boundingBoxCollision\n\n        items = []\n        fifo  = [@]\n\n        while fifo.length > 0\n            top = fifo.shift()\n\n            for elt in top.oversized when elt isnt item and collisionFunction item, elt then items.push elt\n            for elt in top.contents  when elt isnt item and collisionFunction item, elt then items.push elt\n\n            fits = fitting item, top\n\n            # Special case for elements located outside of the quadtree on the right / bottom side\n            if fits.length is 0\n                fits = []\n                if item.x >= top.x + top.width\n                    fits.push 'NE'\n                if item.y >= top.y + top.height\n                    fits.push 'SW'\n                if fits.length > 0\n                    if fits.length is 1 then fits.push 'SE' else fits = ['SE']\n\n            for child in fits when top.children[child].tree?\n                fifo.push top.children[child].tree\n\n        items\n\n    # Alias of `where`.\n    get: (query) ->\n        @where query\n    # Returns an array of elements that match the `query` argument.\n    where: (query) ->\n        # Naïve parsing (missing coordinates)\n        if typeof query is 'object' and (not query.x? or not query.y?)\n            return @find (elt) ->\n                check = true\n                for key of query when query[key] isnt elt[key] then check = false\n                check\n\n        # Optimised parsing\n        validateElement query\n\n        items = []\n        fifo = [@]\n\n        while fifo.length > 0\n            top = fifo.shift()\n\n            for elt in top.oversized\n                check = true\n                for key of query when query[key] isnt elt[key] then check = false\n                items.push elt if check\n            for elt in top.contents\n                check = true\n                for key of query when query[key] isnt elt[key] then check = false\n                items.push elt if check\n\n            relatedChild = top.children[calculateDirection query, top]\n\n            if relatedChild.tree?\n                fifo.push relatedChild.tree\n\n        items\n\n    # For each element of the quadtree, performs the `action` function.\n    #```javascript\n    #quad.each(function(item){ console.log(item) })\n    #```\n    each: (action) ->\n        fifo = [@]\n\n        while fifo.length > 0\n            top = fifo.shift()\n            for i in top.oversized then action?(i)\n            for i in top.contents then action?(i)\n\n            for child of top.children when top.children[child].tree?\n                fifo.push top.children[child].tree\n        @\n\n    # Returns an array of elements which validates the predicate.\n    find: (predicate) ->\n        fifo = [@]\n        items = []\n\n        while fifo.length > 0\n            top = fifo.shift()\n            for i in top.oversized when predicate?(i) then items.push i\n            for i in top.contents when predicate?(i) then items.push i\n\n            for child of top.children when top.children[child].tree?\n                fifo.push top.children[child].tree\n        items\n\n    # Returns a **cloned** `Quadtree` object which contains only the elements that validate the predicate.\n    filter: (predicate) ->\n        deepclone = (target) ->\n            copycat = new Quadtree x: target.x, y: target.y, width: target.width, height: target.height, maxElements: target.maxElements\n            copycat.size = 0\n            for child of target.children when target.children[child].tree?\n                copycat.children[child].tree = deepclone target.children[child].tree\n                copycat.size += copycat.children[child].tree?.size ? 0\n\n            for item in target.oversized when not predicate? or predicate?(item)\n                copycat.oversized.push item\n            for item in target.contents when not predicate? or predicate?(item)\n                copycat.contents.push item\n\n            copycat.size += copycat.oversized.length + copycat.contents.length\n            if copycat.size is 0 then null else copycat\n\n        deepclone @\n\n    # Opposite of filter.\n    reject: (predicate) ->\n        @filter (i) ->\n            not predicate?(i)\n\n    # Visits each tree & subtree contained in the `Quadtree` object.\n    # For each node, performs the `action` function, inside which `this` is bound to the node tree object.\n    visit: (action) ->\n        fifo = [@]\n\n        while fifo.length > 0\n            that = fifo.shift()\n            action.bind(that)()\n\n            for child of that.children when that.children[child].tree?\n                fifo.push that.children[child].tree\n        @\n\n    # Pretty printing function.\n    pretty: ->\n        str = ''\n\n        indent = (level) ->\n            res = ''\n            res += '   ' for times in [level...0]\n            res\n\n        fifo  = [{ label: 'ROOT', tree: @, level: 0 }]\n        while fifo.length > 0\n            top = fifo.shift()\n            indentation = indent(top.level)\n            str += \"\"\"\n                   #{indentation}| #{top.label}\n                   #{indentation}| ------------\\n\n                   \"\"\"\n\n            if top.tree.oversized.length > 0\n                str += \"\"\"\n                       #{indentation}| * Oversized elements *\n                       #{indentation}|   #{top.tree.oversized}\\n\n                       \"\"\"\n\n            if top.tree.contents.length > 0\n                str += \"\"\"\n                       #{indentation}| * Leaf content *\n                       #{indentation}|   #{top.tree.contents}\\n\n                       \"\"\"\n\n            isParent = false\n            for child of top.tree.children when top.tree.children[child].tree?\n                isParent = true\n                fifo.unshift { label: child, tree: top.tree.children[child].tree, level: top.level + 1 }\n\n            if isParent then str += \"#{indentation}└──┐\\n\"\n\n        str\n)\n"]}