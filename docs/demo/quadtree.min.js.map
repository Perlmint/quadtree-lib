{"version":3,"sources":["quadtree.coffee","quadtree.js"],"names":["root","factory","define","amd","exports","module","this","Quadtree","arg","child","that","x","y","width","height","maxElements","Error","contents","oversized","size","children","NW","create","Math","max","floor","tree","NE","ceil","SW","SE","get","calculateDirection","getCenter","isOversized","observe","validateElement","item","ref","ref1","element","quadCenter","writeAccessors","propName","Object","defineProperty","set","val","remove","push","configurable","prototype","doObserve","pushAll","items","candidate","content","contentDir","direction","elements","fifo","fifoCandidates","j","k","l","len","len1","len2","relatedChild","top","length","shift","index","indexOf","splice","colliding","collisionFunction","boundingBoxCollision","elt","elt1","elt2","ref2","ref3","query","where","check","key","find","each","action","i","predicate","filter","deepclone","target","copycat","reject","visit","bind","pretty","indent","indentation","isParent","str","level","res","times","label","unshift"],"mappings":"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","file":"quadtree.min.js","sourcesContent":["# quadtree-lib\n# ============\n#\n# **Quadtree-lib** is an easy to use, developer friendly quadtree library\n# which contains many helper methods to add, remove, iterate, filter, simulate\n# collisions over 2d elements and more.\n\n# #### UMD bundling related code\n((root, factory) ->\n    if typeof define is 'function' and define.amd\n        define [], factory\n    else if typeof exports is 'object' and module.exports\n        module.exports = factory()\n    else\n        root[\"Quadtree\"] = factory()\n) @, (() -> class Quadtree\n    # The Quadtree class\n    # -------------------\n\n    # ### Constructor\n\n    # The quadtree constructor accepts a single parameter object containing the following properties :\n    # - width / length : dimensions of the quadtree. [ *mandatory* ]\n    # - maxElements : the maximum number of elements before the leaf 'splits' into subtrees. [ *defaults to 1* ]\n    # - x / y : these coordinates are used internally by the library to position subtrees. [ *internal use only* ]\n    constructor: ({@x, @y, @width, @height, @maxElements}) ->\n\n        # An error is thrown when the width & length are not passed as constructor arguments.\n        throw new Error \"Missing quadtree dimensions.\" if not @width? or not @height?\n        @x ?= 0\n        @y ?= 0\n        @maxElements ?= 1\n        @contents = []\n        @oversized = []\n        @size = 0\n\n        # Dimension & coordinates are checked, an error is thrown in case of bad input.\n        throw new Error \"Dimensions and coordinates must be positive integers.\" if @x < 0 or @y < 0 or @width < 1 or @height < 1\n        throw new Error \"The maximum number of elements before a split must be a positive integer.\" if @maxElements < 1\n\n        that = @\n\n        # The subtrees list, by position.\n        @children = {\n            # Northwest tree.\n            \"NW\":\n                create: () ->\n                    new Quadtree({\n                        x: that.x\n                        y: that.y\n                        width: Math.max (Math.floor that.width / 2), 1\n                        height: Math.max (Math.floor that.height / 2), 1\n                        maxElements: that.maxElements\n                    })\n                tree: null\n            # Northeast tree.\n            \"NE\":\n                create: () ->\n                    new Quadtree({\n                        x: that.x + Math.max (Math.floor that.width / 2), 1\n                        y: that.y\n                        width: Math.ceil that.width / 2\n                        height: Math.max (Math.floor that.height / 2), 1\n                        maxElements: that.maxElements\n                    })\n                tree: null\n            # Southwest tree.\n            \"SW\":\n                create: () ->\n                    new Quadtree({\n                        x: that.x\n                        y: that.y + Math.max (Math.floor that.height / 2), 1\n                        width: Math.max (Math.floor that.width / 2), 1\n                        height: Math.ceil that.height / 2\n                        maxElements: that.maxElements\n                    })\n                tree: null\n            # Southeast tree.\n            \"SE\":\n                create: () ->\n                    new Quadtree({\n                        x: that.x + Math.max (Math.floor that.width / 2), 1\n                        y: that.y + Math.max (Math.floor that.height / 2), 1\n                        width: Math.ceil that.width / 2\n                        height: Math.ceil that.height / 2\n                        maxElements: that.maxElements\n                    })\n                tree: null\n        }\n        # Adding a getter which lazily creates the tree.\n        for child of @children\n            @children[child].get = () ->\n                if @tree? then @tree else @tree = @create(); @tree\n\n    # ### Internal methods & vars\n\n    # Retrieves the center coordinates of a rectangle.\n    getCenter = (item) ->\n        x: Math.floor((item.width  ? 1) / 2) + item.x\n        y: Math.floor((item.height ? 1) / 2) + item.y\n\n    # Validates a potential element of the tree.\n    validateElement = (element) ->\n        if not typeof element is \"object\" or not element.x? or not element.y? or element.x < 0 or element.y < 0\n            throw new Error \"Object must contain x or y positions as arguments, and they must be positive integers.\"\n        if element?.width < 0 or element?.height < 0\n            throw new Error \"Width and height must be positive integers.\"\n\n    # Determines which subtree an element belongs to.\n    calculateDirection = (element, tree) ->\n        quadCenter = getCenter tree\n\n        if element.x < quadCenter.x\n            if element.y < quadCenter.y then \"NW\"\n            else \"SW\"\n        else\n            if element.y < quadCenter.y then \"NE\"\n            else \"SE\"\n\n    # Determines if an element is oversized.\n    # An oversized element is an element 'too big' to fit into the tree.\n    isOversized = (element, tree) ->\n        element.x < tree.x or\n        element.x + (element.width ? 0) >= tree.x + tree.width or\n        element.y < tree.y or\n        element.y + (element.height ? 0) >= tree.y + tree.height\n\n    # Add getters and setters for coordinates and dimensions properties in order to automatically reorganize the elements on change.\n    observe = (item, tree) ->\n        writeAccessors = (propName) ->\n            item[\"_#{propName}\"] = item[propName]\n            Object.defineProperty item, propName, {\n                set: (val) ->\n                    tree.remove @\n                    @[\"_#{propName}\"] = val\n                    tree.push @\n                get: ->\n                    @[\"_#{propName}\"]\n                configurable: true\n            }\n        writeAccessors \"x\"\n        writeAccessors \"y\"\n        writeAccessors \"width\"\n        writeAccessors \"height\"\n\n    # ### Exposed methods\n\n    # Add an element to the quadtree.\n    # Elements can be observed to reorganize them into the quadtree automatically whenever their coordinates or dimensions are set (for ex. obj.x = ...).\n    push: (item, doObserve) ->\n        @pushAll([item], doObserve)\n\n    # Push an array of elements.\n    pushAll : (items, doObserve) ->\n        for item in items\n            validateElement item\n            observe item, @ if doObserve\n\n        fifo = [tree: @, elements: items]\n\n        while fifo.length > 0\n            top = fifo.shift()\n            tree = top.tree\n            elements = top.elements\n\n            fifoCandidates = { \"NW\": null, \"NE\": null, \"SW\": null, \"SE\": null }\n\n            for element in elements\n                tree.size++\n\n                direction = calculateDirection element, tree\n                relatedChild = tree.children[direction]\n\n                if tree.width is 1 or tree.height is 1 or isOversized element, relatedChild.create()\n                    tree.oversized.push element\n\n                else if (tree.size - tree.oversized.length) <= tree.maxElements\n                    tree.contents.push element\n\n                else\n                    fifoCandidates[direction] ?= { tree: relatedChild.get(), elements: [] }\n                    fifoCandidates[direction].elements.push(element)\n\n                    for content in tree.contents\n                        contentDir = calculateDirection content, tree\n                        fifoCandidates[contentDir] ?= { tree: tree.children[contentDir].get(), elements: [] }\n                        fifoCandidates[contentDir].elements.push(content)\n\n                    tree.contents = []\n\n            for direction, candidate of fifoCandidates\n                if candidate? then fifo.push candidate\n\n        @\n\n    # Removes an element from the quadtree.\n    remove: (item) ->\n        validateElement item\n\n        index = @oversized.indexOf item\n        if index > - 1\n            @oversized.splice index, 1\n            @size--\n            return true\n        index = @contents.indexOf item\n        if index > - 1\n            @contents.splice index, 1\n            @size--\n            return true\n\n        relatedChild = @children[calculateDirection item, @]\n        if not relatedChild.tree?\n            return false\n\n        if relatedChild.tree.remove item\n            @size--\n            relatedChild.tree = null if relatedChild.tree.size is 0\n            true\n        else\n            false\n\n    # Returns an array of elements which collides with the `item` argument.\n    # `item` being an object having x, y, width & height properties.\n\n    # The default collision function is a basic bounding box algorithm.\n    # You can change it by providing a function as a second argument.\n    #```javascript\n    #colliding({x: 10, y: 20}, function(element1, element2){\n    #    return //Predicate\n    #})\n    #```\n    colliding: (item, collisionFunction) ->\n        validateElement item\n\n        boundingBoxCollision = (elt1, elt2) ->\n            not(elt1.x > elt2.x + (elt2.width ? 0)      or\n                elt1.x + (elt1.width ? 0) < elt2.x      or\n                elt1.y > elt2.y + (elt2.height ? 0)     or\n                elt1.y + (elt1.height ? 0) < elt2.y)\n\n        collisionFunction ?= boundingBoxCollision\n\n        items = []\n        fifo  = [@]\n\n        while fifo.length > 0\n            top = fifo.shift()\n\n            for elt in top.oversized when elt isnt item and collisionFunction item, elt then items.push elt\n            for elt in top.contents  when elt isnt item and collisionFunction item, elt then items.push elt\n\n            relatedChild = top.children[calculateDirection item, top]\n\n            if isOversized item, relatedChild.create()\n                for child of top.children\n                    if top.children[child].tree? and boundingBoxCollision(top.children[child].tree, item)\n                        fifo.push top.children[child].tree\n\n            else if relatedChild.tree?\n                fifo.push relatedChild.tree\n\n        items\n\n    # Alias of `where`.\n    get: (query) ->\n        @where query\n    # Returns an array of elements that match the `query` argument.\n    where: (query) ->\n        # Naïve parsing (missing coordinates)\n        if typeof query is \"object\" and not query.x? and not query.y?\n            return @find (elt) ->\n                check = true\n                for key of query when query[key] isnt elt[key] then check = false\n                check\n\n        # Optimised parsing\n        validateElement query\n\n        items = []\n        fifo = [@]\n\n        while fifo.length > 0\n            top = fifo.shift()\n\n            for elt in top.oversized\n                check = true\n                for key of query when query[key] isnt elt[key] then check = false\n                items.push elt if check\n            for elt in top.contents\n                check = true\n                for key of query when query[key] isnt elt[key] then check = false\n                items.push elt if check\n\n            relatedChild = top.children[calculateDirection query, top]\n\n            if relatedChild.tree?\n                fifo.push relatedChild.tree\n\n        items\n\n    # For each element of the quadtree, performs the `action` function.\n    #```javascript\n    #quad.each(function(item){ console.log(item) })\n    #```\n    each: (action) ->\n        fifo = [@]\n\n        while fifo.length > 0\n            top = fifo.shift()\n            for i in top.oversized then action?(i)\n            for i in top.contents then action?(i)\n\n            for child of top.children when top.children[child].tree?\n                fifo.push top.children[child].tree\n        @\n\n    # Returns an array of elements which validate the predicate.\n    find: (predicate) ->\n        fifo = [@]\n        items = []\n\n        while fifo.length > 0\n            top = fifo.shift()\n            for i in top.oversized when predicate?(i) then items.push i\n            for i in top.contents when predicate?(i) then items.push i\n\n            for child of top.children when top.children[child].tree?\n                fifo.push top.children[child].tree\n        items\n\n    # Returns a **cloned** `Quadtree` object which contains only the elements that validate the predicate.\n    filter: (predicate) ->\n        deepclone = (target) ->\n            copycat = new Quadtree x: target.x, y: target.y, width: target.width, height: target.height, maxElements: target.maxElements\n            copycat.size = 0\n            for child of target.children when target.children[child].tree?\n                copycat.children[child].tree = deepclone target.children[child].tree\n                copycat.size += copycat.children[child].tree?.size ? 0\n\n            for item in target.oversized when not predicate? or predicate?(item)\n                copycat.oversized.push item\n            for item in target.contents when not predicate? or predicate?(item)\n                copycat.contents.push item\n\n            copycat.size += copycat.oversized.length + copycat.contents.length\n            if copycat.size is 0 then null else copycat\n\n        deepclone @\n\n    # Opposite of filter.\n    reject: (predicate) ->\n        @filter (i) ->\n            not predicate?(i)\n\n    # Visits each tree & subtree contained in the `Quadtree` object.\n    # For each node, performs the `action` function, inside which `this` is bound to the node tree object.\n    visit: (action) ->\n        fifo = [@]\n\n        while fifo.length > 0\n            that = fifo.shift()\n            action.bind(that)()\n\n            for child of that.children when that.children[child].tree?\n                fifo.push that.children[child].tree\n        @\n\n    # Pretty printing function.\n    pretty: () ->\n        str = \"\"\n\n        indent = (level) ->\n            res = \"\"\n            res += \"   \" for times in [level...0]\n            res\n\n        fifo  = [{ label: \"ROOT\", tree: @, level: 0 }]\n        while fifo.length > 0\n            top = fifo.shift()\n            indentation = indent(top.level)\n            str += \"\"\"\n                   #{indentation}| #{top.label}\n                   #{indentation}| ------------\\n\n                   \"\"\"\n\n            if top.tree.oversized.length > 0\n                str += \"\"\"\n                       #{indentation}| * Oversized elements *\n                       #{indentation}|   #{top.tree.oversized}\\n\n                       \"\"\"\n\n            if top.tree.contents.length > 0\n                str += \"\"\"\n                       #{indentation}| * Leaf content *\n                       #{indentation}|   #{top.tree.contents}\\n\n                       \"\"\"\n\n            isParent = false\n            for child of top.tree.children when top.tree.children[child].tree?\n                isParent = true\n                fifo.unshift { label: child, tree: top.tree.children[child].tree, level: top.level + 1 }\n\n            if isParent then str += \"#{indentation}└──┐\\n\"\n\n        str\n)\n","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    return define([], factory);\n  } else if (typeof exports === 'object' && module.exports) {\n    return module.exports = factory();\n  } else {\n    return root[\"Quadtree\"] = factory();\n  }\n})(this, (function() {\n  var Quadtree;\n  return Quadtree = (function() {\n    var calculateDirection, getCenter, isOversized, observe, validateElement;\n\n    function Quadtree(arg) {\n      var child, that;\n      this.x = arg.x, this.y = arg.y, this.width = arg.width, this.height = arg.height, this.maxElements = arg.maxElements;\n      if ((this.width == null) || (this.height == null)) {\n        throw new Error(\"Missing quadtree dimensions.\");\n      }\n      if (this.x == null) {\n        this.x = 0;\n      }\n      if (this.y == null) {\n        this.y = 0;\n      }\n      if (this.maxElements == null) {\n        this.maxElements = 1;\n      }\n      this.contents = [];\n      this.oversized = [];\n      this.size = 0;\n      if (this.x < 0 || this.y < 0 || this.width < 1 || this.height < 1) {\n        throw new Error(\"Dimensions and coordinates must be positive integers.\");\n      }\n      if (this.maxElements < 1) {\n        throw new Error(\"The maximum number of elements before a split must be a positive integer.\");\n      }\n      that = this;\n      this.children = {\n        \"NW\": {\n          create: function() {\n            return new Quadtree({\n              x: that.x,\n              y: that.y,\n              width: Math.max(Math.floor(that.width / 2), 1),\n              height: Math.max(Math.floor(that.height / 2), 1),\n              maxElements: that.maxElements\n            });\n          },\n          tree: null\n        },\n        \"NE\": {\n          create: function() {\n            return new Quadtree({\n              x: that.x + Math.max(Math.floor(that.width / 2), 1),\n              y: that.y,\n              width: Math.ceil(that.width / 2),\n              height: Math.max(Math.floor(that.height / 2), 1),\n              maxElements: that.maxElements\n            });\n          },\n          tree: null\n        },\n        \"SW\": {\n          create: function() {\n            return new Quadtree({\n              x: that.x,\n              y: that.y + Math.max(Math.floor(that.height / 2), 1),\n              width: Math.max(Math.floor(that.width / 2), 1),\n              height: Math.ceil(that.height / 2),\n              maxElements: that.maxElements\n            });\n          },\n          tree: null\n        },\n        \"SE\": {\n          create: function() {\n            return new Quadtree({\n              x: that.x + Math.max(Math.floor(that.width / 2), 1),\n              y: that.y + Math.max(Math.floor(that.height / 2), 1),\n              width: Math.ceil(that.width / 2),\n              height: Math.ceil(that.height / 2),\n              maxElements: that.maxElements\n            });\n          },\n          tree: null\n        }\n      };\n      for (child in this.children) {\n        this.children[child].get = function() {\n          if (this.tree != null) {\n            return this.tree;\n          } else {\n            this.tree = this.create();\n            return this.tree;\n          }\n        };\n      }\n    }\n\n    getCenter = function(item) {\n      var ref, ref1;\n      return {\n        x: Math.floor(((ref = item.width) != null ? ref : 1) / 2) + item.x,\n        y: Math.floor(((ref1 = item.height) != null ? ref1 : 1) / 2) + item.y\n      };\n    };\n\n    validateElement = function(element) {\n      if (!typeof element === \"object\" || (element.x == null) || (element.y == null) || element.x < 0 || element.y < 0) {\n        throw new Error(\"Object must contain x or y positions as arguments, and they must be positive integers.\");\n      }\n      if ((element != null ? element.width : void 0) < 0 || (element != null ? element.height : void 0) < 0) {\n        throw new Error(\"Width and height must be positive integers.\");\n      }\n    };\n\n    calculateDirection = function(element, tree) {\n      var quadCenter;\n      quadCenter = getCenter(tree);\n      if (element.x < quadCenter.x) {\n        if (element.y < quadCenter.y) {\n          return \"NW\";\n        } else {\n          return \"SW\";\n        }\n      } else {\n        if (element.y < quadCenter.y) {\n          return \"NE\";\n        } else {\n          return \"SE\";\n        }\n      }\n    };\n\n    isOversized = function(element, tree) {\n      var ref, ref1;\n      return element.x < tree.x || element.x + ((ref = element.width) != null ? ref : 0) >= tree.x + tree.width || element.y < tree.y || element.y + ((ref1 = element.height) != null ? ref1 : 0) >= tree.y + tree.height;\n    };\n\n    observe = function(item, tree) {\n      var writeAccessors;\n      writeAccessors = function(propName) {\n        item[\"_\" + propName] = item[propName];\n        return Object.defineProperty(item, propName, {\n          set: function(val) {\n            tree.remove(this);\n            this[\"_\" + propName] = val;\n            return tree.push(this);\n          },\n          get: function() {\n            return this[\"_\" + propName];\n          },\n          configurable: true\n        });\n      };\n      writeAccessors(\"x\");\n      writeAccessors(\"y\");\n      writeAccessors(\"width\");\n      return writeAccessors(\"height\");\n    };\n\n    Quadtree.prototype.push = function(item, doObserve) {\n      return this.pushAll([item], doObserve);\n    };\n\n    Quadtree.prototype.pushAll = function(items, doObserve) {\n      var candidate, content, contentDir, direction, element, elements, fifo, fifoCandidates, item, j, k, l, len, len1, len2, ref, relatedChild, top, tree;\n      for (j = 0, len = items.length; j < len; j++) {\n        item = items[j];\n        validateElement(item);\n        if (doObserve) {\n          observe(item, this);\n        }\n      }\n      fifo = [\n        {\n          tree: this,\n          elements: items\n        }\n      ];\n      while (fifo.length > 0) {\n        top = fifo.shift();\n        tree = top.tree;\n        elements = top.elements;\n        fifoCandidates = {\n          \"NW\": null,\n          \"NE\": null,\n          \"SW\": null,\n          \"SE\": null\n        };\n        for (k = 0, len1 = elements.length; k < len1; k++) {\n          element = elements[k];\n          tree.size++;\n          direction = calculateDirection(element, tree);\n          relatedChild = tree.children[direction];\n          if (tree.width === 1 || tree.height === 1 || isOversized(element, relatedChild.create())) {\n            tree.oversized.push(element);\n          } else if ((tree.size - tree.oversized.length) <= tree.maxElements) {\n            tree.contents.push(element);\n          } else {\n            if (fifoCandidates[direction] == null) {\n              fifoCandidates[direction] = {\n                tree: relatedChild.get(),\n                elements: []\n              };\n            }\n            fifoCandidates[direction].elements.push(element);\n            ref = tree.contents;\n            for (l = 0, len2 = ref.length; l < len2; l++) {\n              content = ref[l];\n              contentDir = calculateDirection(content, tree);\n              if (fifoCandidates[contentDir] == null) {\n                fifoCandidates[contentDir] = {\n                  tree: tree.children[contentDir].get(),\n                  elements: []\n                };\n              }\n              fifoCandidates[contentDir].elements.push(content);\n            }\n            tree.contents = [];\n          }\n        }\n        for (direction in fifoCandidates) {\n          candidate = fifoCandidates[direction];\n          if (candidate != null) {\n            fifo.push(candidate);\n          }\n        }\n      }\n      return this;\n    };\n\n    Quadtree.prototype.remove = function(item) {\n      var index, relatedChild;\n      validateElement(item);\n      index = this.oversized.indexOf(item);\n      if (index > -1) {\n        this.oversized.splice(index, 1);\n        this.size--;\n        return true;\n      }\n      index = this.contents.indexOf(item);\n      if (index > -1) {\n        this.contents.splice(index, 1);\n        this.size--;\n        return true;\n      }\n      relatedChild = this.children[calculateDirection(item, this)];\n      if (relatedChild.tree == null) {\n        return false;\n      }\n      if (relatedChild.tree.remove(item)) {\n        this.size--;\n        if (relatedChild.tree.size === 0) {\n          relatedChild.tree = null;\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    Quadtree.prototype.colliding = function(item, collisionFunction) {\n      var boundingBoxCollision, child, elt, fifo, items, j, k, len, len1, ref, ref1, relatedChild, top;\n      validateElement(item);\n      boundingBoxCollision = function(elt1, elt2) {\n        var ref, ref1, ref2, ref3;\n        return !(elt1.x > elt2.x + ((ref = elt2.width) != null ? ref : 0) || elt1.x + ((ref1 = elt1.width) != null ? ref1 : 0) < elt2.x || elt1.y > elt2.y + ((ref2 = elt2.height) != null ? ref2 : 0) || elt1.y + ((ref3 = elt1.height) != null ? ref3 : 0) < elt2.y);\n      };\n      if (collisionFunction == null) {\n        collisionFunction = boundingBoxCollision;\n      }\n      items = [];\n      fifo = [this];\n      while (fifo.length > 0) {\n        top = fifo.shift();\n        ref = top.oversized;\n        for (j = 0, len = ref.length; j < len; j++) {\n          elt = ref[j];\n          if (elt !== item && collisionFunction(item, elt)) {\n            items.push(elt);\n          }\n        }\n        ref1 = top.contents;\n        for (k = 0, len1 = ref1.length; k < len1; k++) {\n          elt = ref1[k];\n          if (elt !== item && collisionFunction(item, elt)) {\n            items.push(elt);\n          }\n        }\n        relatedChild = top.children[calculateDirection(item, top)];\n        if (isOversized(item, relatedChild.create())) {\n          for (child in top.children) {\n            if ((top.children[child].tree != null) && boundingBoxCollision(top.children[child].tree, item)) {\n              fifo.push(top.children[child].tree);\n            }\n          }\n        } else if (relatedChild.tree != null) {\n          fifo.push(relatedChild.tree);\n        }\n      }\n      return items;\n    };\n\n    Quadtree.prototype.get = function(query) {\n      return this.where(query);\n    };\n\n    Quadtree.prototype.where = function(query) {\n      var check, elt, fifo, items, j, k, key, len, len1, ref, ref1, relatedChild, top;\n      if (typeof query === \"object\" && (query.x == null) && (query.y == null)) {\n        return this.find(function(elt) {\n          var check, key;\n          check = true;\n          for (key in query) {\n            if (query[key] !== elt[key]) {\n              check = false;\n            }\n          }\n          return check;\n        });\n      }\n      validateElement(query);\n      items = [];\n      fifo = [this];\n      while (fifo.length > 0) {\n        top = fifo.shift();\n        ref = top.oversized;\n        for (j = 0, len = ref.length; j < len; j++) {\n          elt = ref[j];\n          check = true;\n          for (key in query) {\n            if (query[key] !== elt[key]) {\n              check = false;\n            }\n          }\n          if (check) {\n            items.push(elt);\n          }\n        }\n        ref1 = top.contents;\n        for (k = 0, len1 = ref1.length; k < len1; k++) {\n          elt = ref1[k];\n          check = true;\n          for (key in query) {\n            if (query[key] !== elt[key]) {\n              check = false;\n            }\n          }\n          if (check) {\n            items.push(elt);\n          }\n        }\n        relatedChild = top.children[calculateDirection(query, top)];\n        if (relatedChild.tree != null) {\n          fifo.push(relatedChild.tree);\n        }\n      }\n      return items;\n    };\n\n    Quadtree.prototype.each = function(action) {\n      var child, fifo, i, j, k, len, len1, ref, ref1, top;\n      fifo = [this];\n      while (fifo.length > 0) {\n        top = fifo.shift();\n        ref = top.oversized;\n        for (j = 0, len = ref.length; j < len; j++) {\n          i = ref[j];\n          if (typeof action === \"function\") {\n            action(i);\n          }\n        }\n        ref1 = top.contents;\n        for (k = 0, len1 = ref1.length; k < len1; k++) {\n          i = ref1[k];\n          if (typeof action === \"function\") {\n            action(i);\n          }\n        }\n        for (child in top.children) {\n          if (top.children[child].tree != null) {\n            fifo.push(top.children[child].tree);\n          }\n        }\n      }\n      return this;\n    };\n\n    Quadtree.prototype.find = function(predicate) {\n      var child, fifo, i, items, j, k, len, len1, ref, ref1, top;\n      fifo = [this];\n      items = [];\n      while (fifo.length > 0) {\n        top = fifo.shift();\n        ref = top.oversized;\n        for (j = 0, len = ref.length; j < len; j++) {\n          i = ref[j];\n          if (typeof predicate === \"function\" ? predicate(i) : void 0) {\n            items.push(i);\n          }\n        }\n        ref1 = top.contents;\n        for (k = 0, len1 = ref1.length; k < len1; k++) {\n          i = ref1[k];\n          if (typeof predicate === \"function\" ? predicate(i) : void 0) {\n            items.push(i);\n          }\n        }\n        for (child in top.children) {\n          if (top.children[child].tree != null) {\n            fifo.push(top.children[child].tree);\n          }\n        }\n      }\n      return items;\n    };\n\n    Quadtree.prototype.filter = function(predicate) {\n      var deepclone;\n      deepclone = function(target) {\n        var child, copycat, item, j, k, len, len1, ref, ref1, ref2, ref3;\n        copycat = new Quadtree({\n          x: target.x,\n          y: target.y,\n          width: target.width,\n          height: target.height,\n          maxElements: target.maxElements\n        });\n        copycat.size = 0;\n        for (child in target.children) {\n          if (!(target.children[child].tree != null)) {\n            continue;\n          }\n          copycat.children[child].tree = deepclone(target.children[child].tree);\n          copycat.size += (ref = (ref1 = copycat.children[child].tree) != null ? ref1.size : void 0) != null ? ref : 0;\n        }\n        ref2 = target.oversized;\n        for (j = 0, len = ref2.length; j < len; j++) {\n          item = ref2[j];\n          if ((predicate == null) || (typeof predicate === \"function\" ? predicate(item) : void 0)) {\n            copycat.oversized.push(item);\n          }\n        }\n        ref3 = target.contents;\n        for (k = 0, len1 = ref3.length; k < len1; k++) {\n          item = ref3[k];\n          if ((predicate == null) || (typeof predicate === \"function\" ? predicate(item) : void 0)) {\n            copycat.contents.push(item);\n          }\n        }\n        copycat.size += copycat.oversized.length + copycat.contents.length;\n        if (copycat.size === 0) {\n          return null;\n        } else {\n          return copycat;\n        }\n      };\n      return deepclone(this);\n    };\n\n    Quadtree.prototype.reject = function(predicate) {\n      return this.filter(function(i) {\n        return !(typeof predicate === \"function\" ? predicate(i) : void 0);\n      });\n    };\n\n    Quadtree.prototype.visit = function(action) {\n      var child, fifo, that;\n      fifo = [this];\n      while (fifo.length > 0) {\n        that = fifo.shift();\n        action.bind(that)();\n        for (child in that.children) {\n          if (that.children[child].tree != null) {\n            fifo.push(that.children[child].tree);\n          }\n        }\n      }\n      return this;\n    };\n\n    Quadtree.prototype.pretty = function() {\n      var child, fifo, indent, indentation, isParent, str, top;\n      str = \"\";\n      indent = function(level) {\n        var j, ref, res, times;\n        res = \"\";\n        for (times = j = ref = level; ref <= 0 ? j < 0 : j > 0; times = ref <= 0 ? ++j : --j) {\n          res += \"   \";\n        }\n        return res;\n      };\n      fifo = [\n        {\n          label: \"ROOT\",\n          tree: this,\n          level: 0\n        }\n      ];\n      while (fifo.length > 0) {\n        top = fifo.shift();\n        indentation = indent(top.level);\n        str += indentation + \"| \" + top.label + \"\\n\" + indentation + \"| ------------\\n\";\n        if (top.tree.oversized.length > 0) {\n          str += indentation + \"| * Oversized elements *\\n\" + indentation + \"|   \" + top.tree.oversized + \"\\n\";\n        }\n        if (top.tree.contents.length > 0) {\n          str += indentation + \"| * Leaf content *\\n\" + indentation + \"|   \" + top.tree.contents + \"\\n\";\n        }\n        isParent = false;\n        for (child in top.tree.children) {\n          if (!(top.tree.children[child].tree != null)) {\n            continue;\n          }\n          isParent = true;\n          fifo.unshift({\n            label: child,\n            tree: top.tree.children[child].tree,\n            level: top.level + 1\n          });\n        }\n        if (isParent) {\n          str += indentation + \"└──┐\\n\";\n        }\n      }\n      return str;\n    };\n\n    return Quadtree;\n\n  })();\n}));\n\n//# sourceMappingURL=quadtree.js.map\n"]}